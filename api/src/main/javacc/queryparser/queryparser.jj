options {
  LOOKAHEAD = 5;
}

PARSER_BEGIN(QueryParser)

package com.rbmhtechnology.vind.parser.queryparser;

import org.apache.commons.lang3.StringUtils;
import java.util.ArrayList;

public class QueryParser {
    public Query run() throws ParseException {
        return query();
    }
};

PARSER_END(QueryParser)
SKIP : {
    <" " | "\t" | "\n" | "\r" >
}
TOKEN :
{
  <AND:              (("a" | "A")("n" | "N")("d" | "D")) | "&">
| <OR:               (("o"|"O")("r" | "R")) | "|">
| <NOT:              (("n"|"N")("o"|"O")("t"|"T")) | "!">
| <PLUS:             "+">
| <MINUS:            "-" >
| <LPAREN:           "(">
| <RPAREN:           ")">
| <LBRACKET:         "[">
| <RBRACKET:         "]">
| <DATE_TERM:        (<NUMBER><NUMBER>(<NUMBER><NUMBER>)?["/","-","."]<NUMBER><NUMBER>["/","-","."]<NUMBER><NUMBER>(<NUMBER><NUMBER>)?)  >
| <NUMBER_TERM:      (["+","-"])? ( (<NUMBER>)+ ("."(<NUMBER>)*)? ) (["e","E"](<NUMBER>)+)? >
| <FIELD:            (["0"-"9","A"-"Z","a"-"z","_","-","."])+ ":" >
| <QUOTE:           "\"">
| <QUOTED_STRING:   <QUOTE> (~["\""])+ <QUOTE> >
| <WILDCARD:        "*">
| <TO:              ("t"|"T")("o"|"O")>
| <TERM:             (["0"-"9","A"-"Z","a"-"z","_","-","\u0080"-"\uffff"])+ >
| <NUMBER:           ["0"-"9"]>
}

Query query() :
{Query q = new Query();Clause c;Token value;}
{
    ( c=expresion() {q.add(c);})*
    (value=<TERM>{q.addText(value.image);}
    | value=<QUOTED_STRING>{q.addText(value.image);}
    | value=<AND>{q.addText(value.image);}
    | value=<OR>{q.addText(value.image);}
    | value=<NOT>{q.addText(value.image);}
    | value=<MINUS> {q.addText(value.image);}
    | value=<PLUS> {q.addText(value.image);}
    | value=<WILDCARD> {q.addText(value.image);}
    | value=<NUMBER_TERM> {q.addText(value.image);}
    )*
    { return q;}
}

FieldClause fieldClause() :
{BooleanLiteral query = null;boolean negated = false;Token field = null;SimpleLiteral value = null;}
{
    (<PLUS> | <MINUS>{negated=true;})?
    field=<FIELD>
    (value=simpleLiteral() | ( query=booleanLiteral() ))
      {
        String fieldName = field == null ? null : StringUtils.chop(field.image);
        return query == null ?
            new SimpleTermClause(negated, fieldName, value) :
            new ComplexTermClause(negated, fieldName, query);
      }
}
SimpleLiteral simpleLiteral() :
{SimpleLiteral literal;}
{
    ( literal=rangeLiteral() | literal=termsLiteral() )
    {return literal;}
}
TermsLiteral termsLiteral() :
{TermsLiteral l = new TermsLiteral();Token value;}
{
    ( value=<TERM>{l.add(value.image);}
    | value=<QUOTED_STRING>{l.add(value.image);}
    | value=<NUMBER_TERM> {l.add(value.image);}
    | ( <LPAREN>
        (value=<TERM>{l.add(value.image);} |
         value=<QUOTED_STRING>{l.add(value.image);} |
         value=<NUMBER_TERM> {l.add(value.image);})+ <RPAREN>
        ))

    { return l;}
}

BooleanLiteral booleanLiteral() :
{BooleanLiteral literal;}
{   (literal=unaryBooleanLiteral() | literal=multiBooleanLiteral() |<LPAREN> literal=booleanLeafValue() <RPAREN> | literal=booleanLeafValue() )
    { return literal; }
}

BooleanLiteral unaryBooleanLiteral() :
{BooleanLiteral literal;Token op;}
{
    (op=<NOT> | op=<MINUS> ) (literal=booleanLiteral() )
    { return new UnaryBooleanLiteral(op.image, literal);}
}

BooleanLiteral multiBooleanLiteral() :
{BooleanLiteral left;BooleanLiteral right;Token op;MultiBooleanLiteral baseClause;}
{
    <LPAREN>
     (left=booleanLiteral() ) ( op=<AND> | op=<OR> ) (right=booleanLiteral() )
     {baseClause = new MultiBooleanLiteral(op.image, left, right);}
     (( op=<AND> | op=<OR> ) ( right=booleanLiteral() ) {baseClause.addClause(op.image, right);})*
     <RPAREN>
    { return baseClause; }
}

BooleanLiteral booleanLeafValue():
{Token value;}
{
    ( value=<TERM> | value=<QUOTED_STRING>)
    {return new BooleanLeafLiteral(value.image);}
}

RangeLiteral rangeLiteral() :
{RangeLiteral range;}
{
   (range=numericRangeLiteral() | range=dateRangeLiteral() )
    {return range;}
}

NumericRangeLiteral numericRangeLiteral() :
{Token from;Token to;}
{
    <LBRACKET> ( from=<NUMBER_TERM> | from=<WILDCARD> ) <TO> ( to=<NUMBER_TERM> | to=<WILDCARD> ) <RBRACKET>
    {return new NumericRangeLiteral(from.image, to.image);}
}

DateRangeLiteral dateRangeLiteral() :
{Token from;Token to;}
{
    <LBRACKET> ( from=<DATE_TERM> | from=<WILDCARD> ) <TO> ( to=<DATE_TERM> | to=<WILDCARD> ) <RBRACKET>
    {return new DateRangeLiteral(from.image, to.image);}
}


BooleanClause unaryBooleanClause() :
{Clause clause;Token op;}
{
    (op=<NOT>) (clause=expresion())
    { return new UnaryBooleanClause(op.image, clause);}
}

Clause expresion() :
{Clause clause;ArrayList<Clause> clauses=new ArrayList();MultiBooleanClause boolClause;Token op=null;}
{  clause=clause(){clauses.add(clause);} (op=<OR> clause=clause(){clauses.add(clause);})*
    {
        if( clauses.size()==1) {
            return clause;
        } else {
            boolClause = new MultiBooleanClause(op.image,clauses.get(0),clauses.get(1));
            for (int i = 2; i<clauses.size();i++) {
                boolClause.addClause(op.image, clauses.get(i));
            }
            return boolClause;
        }
    }
}

Clause clause() :
{Clause clause;ArrayList<Clause> clauses=new ArrayList();MultiBooleanClause boolClause;Token op=null;}
{  clause=baseClause(){clauses.add(clause);} (op=<AND> clause=baseClause(){clauses.add(clause);})*
    {
        if( clauses.size()==1) {
            return clause;
        } else {
            boolClause = new MultiBooleanClause(op.image,clauses.get(0),clauses.get(1));
            for (int i = 2; i<clauses.size();i++) {
                boolClause.addClause(op.image, clauses.get(i));
            }
            return boolClause;
        }
    }
}

Clause baseClause() :
{Clause clause;}
{
    (<LPAREN> clause=expresion() <RPAREN> | clause=fieldClause() | clause=unaryBooleanClause() )
    {return clause;}
}
